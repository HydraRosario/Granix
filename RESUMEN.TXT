# Análisis de Arquitectura y Flujo de Datos del Proyecto Granix

A continuación se presenta un análisis detallado de la arquitectura, flujo de datos y lógica de negocio del sistema, basado en el código fuente proporcionado.

## 1. Análisis de la Lógica de Geocodificación

La función de geocodificación, `geocode_address`, se encuentra centralizada en `shared_utils.py`, lo cual es una buena práctica.

**Descripción del Funcionamiento:**
*   **Bounding Box:** La función utiliza `geopy.geocoders.Nominatim` y prioriza los resultados dentro de un "bounding box" (un área geográfica definida) que corresponde a la ciudad de Rosario, Argentina. Esto aumenta significativamente la precisión de las direcciones locales.
*   **Dirección de Respaldo (Fallback):** Si la geocodificación dentro del "bounding box" falla, la función intenta una segunda vez sin esta restricción. Si ambos intentos fallan, o si la dirección de entrada está vacía, se utiliza una dirección de respaldo (`DEFAULT_START_ADDRESS` = "Mendoza y Wilde, Rosario, Santa Fe, Argentina") para evitar errores catastróficos, aunque esto podría llevar a datos de ubicación incorrectos si la geocodificación falla con frecuencia.

**Fragmento de Código Relevante (`shared_utils.py`):**
```python
def geocode_address(address_string: str) -> dict:
    # ...
    ROSARIO_VIEWBOX = [(-33.016, -60.75), (-32.85, -60.6)]
    # ...
    try:
        # Intento 1: Con bounding box
        location = geolocator.geocode(
            full_query, 
            country_codes='ar', 
            timeout=10, 
            viewbox=ROSARIO_VIEWBOX, 
            bounded=True
        )
        
        if location:
            return {"latitude": location.latitude, "longitude": location.longitude}
        else:
            # Intento 2: Sin bounding box (fallback)
            logger.warning(f"Nominatim no pudo geocodificar la dirección: {full_query}. Intentando sin viewbox.")
            location = geolocator.geocode(full_query, country_codes='ar', timeout=10)
            # ...
```

**Módulos que la Utilizan:**
*   `customer_service.py`: Al crear un nuevo cliente (`upsert_customer`), se geocodifica su dirección para almacenar las coordenadas en Firestore.
*   `route_optimizer.py`: Geocodifica la dirección del depósito ("Mendoza 8195, Rosario...") y, si es necesario, cualquier dirección de entrega que no tenga coordenadas preexistentes antes de iniciar la optimización.

## 2. Rastreo del Flujo de Datos

El flujo de datos desde la carga de un informe de reparto hasta el guardado de la ruta es el siguiente:

1.  **Carga del Archivo:** Un usuario sube un archivo (imagen o PDF) al endpoint `/process_delivery_report` en `routes.py`.
2.  **Extracción de Texto (OCR):** El sistema extrae el texto crudo del archivo.
3.  **Parseo del Informe de Reparto:** La clase `DeliveryReportParser` (`delivery_parser.py`) procesa el texto crudo para extraer una lista de `delivery_items`.
    *   **Datos Extraídos:** Para cada ítem, se extrae: `type` (Factura/Remito), `invoice_number`, `commercial_entity`, `delivery_address`, `packages` (cantidad de bultos) y `delivery_instructions`.
4.  **Enriquecimiento de Datos (Flujo Implícito):** Aunque no está completamente implementado en el endpoint `process_delivery_report`, el sistema está diseñado para que, con el `invoice_number` de cada `delivery_item`, se pueda consultar la colección `invoices` en Firestore.
    *   **Datos Adicionales de Facturas:** Al consultar una factura, se pueden obtener `product_items` (con `product_code` y `quantity` de cajas) y el `client_name` formal.
5.  **Optimización de Ruta:** Los datos de las direcciones de entrega (`delivery_address`) se envían a la función `optimize_route` en `route_optimizer.py`.
6.  **Guardado en Firestore:** La ruta optimizada resultante se guarda en la colección `daily_routes` de Firestore, bajo un documento con la fecha del día.

**Fragmento de Código Relevante (`routes.py`):**
```python
@transport_bp.post("/process_delivery_report")
def process_delivery_report():
    # ... (recepción y OCR del archivo) ...

    # El servicio ahora parsea, enriquece y optimiza la ruta
    parsed_report_data = parse_delivery_report_text(raw_ocr_text)

    # Guardar la ruta optimizada en Firestore si existe
    optimized_route = parsed_report_data.get('optimized_route')
    if optimized_route:
        db = firestore.client()
        today_str = datetime.now().strftime("%Y-%m-%d")
        route_doc_ref = db.collection('daily_routes').document(today_str)
        # ... (código de guardado) ...
```

## 3. Evaluación de la Optimización de Ruta

El sistema utiliza Google OR-Tools para resolver el Problema del Viajante de Comercio (TSP).

**Alimentación del Algoritmo:**
*   La función `optimize_route` recibe una lista de direcciones.
*   Construye una matriz de distancias (`distance_matrix`) calculando la distancia haversine (en línea recta) entre las coordenadas de todas las paradas.
*   Esta matriz de distancias se registra en el modelo de OR-Tools como el "costo" de viajar entre nodos.

**Gestión del Punto de Partida/Llegada:**
*   El punto de partida y llegada (el depósito) está hardcodeado como `"Mendoza 8195, Rosario, Santa Fe, Argentina"`.
*   Esta dirección se geocodifica y se inserta en la posición `0` de la lista de ubicaciones.
*   Al configurar el `RoutingIndexManager` de OR-Tools, se especifica que el nodo de inicio y el nodo de fin son ambos el índice `0`, forzando a la ruta a ser un circuito cerrado que empieza y termina en el depósito.

**Fragmento de Código Relevante (`route_optimizer.py`):**
```python
def optimize_route(addresses: list):
    # ...
    # 1. Definir el depósito y obtener sus coordenadas.
    depot_address = "Mendoza 8195, Rosario, Santa Fe, Argentina"
    depot_coords = geocode_address(depot_address)
    # ...
    # 2. Preparar la lista de todas las paradas (depósito + entregas).
    all_locations = [depot_location] + addresses
    # ...
    # 4. Configurar y resolver el problema de enrutamiento con OR-Tools.
    manager = pywrapcp.RoutingIndexManager(num_locations, 1, [0], [0]) # Inicio y fin en el nodo 0
    routing = pywrapcp.RoutingModel(manager)
    # ...
```

## 4. Identificación de Puntos de Conexión

La conexión entre los datos del informe de reparto y los datos de las facturas individuales es **crucial** y se realiza a través del campo `invoice_number`.

1.  El `DeliveryReportParser` extrae el `invoice_number` de cada línea del informe de reparto.
2.  El `InvoiceService` (al procesar facturas individuales) también extrae un `invoice_number` y lo guarda en Firestore.
3.  El flujo de trabajo previsto es: iterar sobre los `delivery_items` del informe, y para cada uno, usar su `invoice_number` para realizar una consulta a la colección `invoices` de Firestore y así obtener los detalles completos de esa factura (productos, cantidades, etc.).

Este mecanismo es el pilar para poder combinar la información logística del reparto con la información comercial de la factura.

## 5. Resumen de la Estructura de la Base de Datos (Firestore)

Basado en el código, la estructura de las colecciones principales es:

*   **Colección `customers`:**
    *   **ID de Documento:** UUID (`new_customer_id`).
    *   **Campos Clave:**
        *   `address`: Dirección física del cliente.
        *   `coordinates`: Objeto con `latitude` y `longitude`.
        *   `client_name`: Nombre fiscal/formal (obtenido de la factura).
        *   `commercial_name`: Nombre comercial (obtenido del informe de reparto).
        *   `delivery_instructions`: Instrucciones de entrega.
        *   `created_at`, `last_updated_at`: Timestamps.

*   **Colección `invoices`:**
    *   **ID de Documento:** UUID (`invoice_id`).
    *   **Campos Clave:**
        *   `invoiceNumber`: Número de factura (ej: `0004-00123456`).
        *   `cloudinaryImageUrl`: URL de la imagen de la factura.
        *   `parsedData`: Objeto que contiene los datos extraídos del OCR, incluyendo:
            *   `client_name`, `address`, `total_amount`.
            *   `product_items`: Un array de objetos, donde cada objeto tiene `product_code`, `quantity`, `description`.
        *   `location`: Objeto con `address` y las coordenadas `latitude` y `longitude`.
        *   `uploadedAt`, `processedAt`: Timestamps.

## Conclusión: Fortalezas y Debilidades para la Optimización de Carga

**Fortalezas:**
*   **Arquitectura Modular:** La separación de responsabilidades (`CustomerService`, `InvoiceService`, `RouteOptimizer`) facilita la extensión del sistema.
*   **Punto de Conexión Claro:** El uso de `invoice_number` como clave de unión entre repartos y facturas es robusto y permite el enriquecimiento de datos necesario para la optimización de carga.
*   **Base de Datos Flexible:** Firestore permite añadir fácilmente nuevos campos a los documentos de `invoices` (como peso, volumen, dimensiones de productos) sin necesidad de migraciones de esquema complejas.
*   **Procesamiento de Datos Establecido:** El sistema ya extrae la cantidad de productos (`quantity`) y el código de producto (`product_code`) de las facturas, que son la base para calcular el volumen o peso.

**Debilidades:**
*   **Enfoque Actual en Enrutamiento, no en Carga:** El `route_optimizer` está diseñado para resolver el TSP (la ruta más corta), no el "Bin Packing Problem" (cómo encajar objetos en un contenedor). La lógica actual no considera volumen, peso o restricciones de apilamiento.
*   **Datos Faltantes para Carga:** El modelo de datos actual, tanto en el parseo como en Firestore, no captura dimensiones (largo, ancho, alto) ni peso de los productos. Solo se enfoca en la `quantity` (cantidad de cajas). Esta información es **indispensable** para una optimización de carga real.
*   **Algoritmo Inadecuado:** El algoritmo de OR-Tools implementado es para enrutamiento. Para la optimización de carga se necesitaría implementar un algoritmo diferente, posiblemente también de OR-Tools pero enfocado en Bin Packing.
*   **Capacidad del Vehículo no Definida:** El modelo actual asume un solo vehículo de capacidad infinita. No hay un lugar donde se definan las dimensiones o capacidad de peso/volumen del vehículo de reparto.
